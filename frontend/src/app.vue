<template lang="pug">
#app
  loading-overlay.overlay-loader(
    v-cloak,
    v-bind:active.sync="isLoadingOverlayEnabled",
    v-bind:opacity='loadingOverlayOpacity',
    v-bind:is-full-page="true"
  )
    template(v-slot:default)
      i.overlay-loading-icon.fa.fa-spinner.fa-spin()
    template(v-slot:after)
      h3 {{ loadingOverlayMessage }}

  template(v-if="userUpdated")
    v-resizer
      template(v-slot:left)
        #summary-wrapper
          v-summary.tab-padding(
            ref="summary",
            v-bind:repos="users",
            v-bind:error-messages="errorMessages"
          )
          .timestamp-footer
            span Generated by&nbsp;
            a(
              v-bind:href="getSpecificCommitLink()", target="_blank"
            )
              strong this version
            span &nbsp;of&nbsp;
            a(
              v-bind:href="getRepoSenseHomeLink()", target="_blank"
            )
              strong RepoSense
            span &nbsp;(
            a(
              v-bind:href="getUserGuideLink()", target ="_blank"
            )
              strong User Guide
            span ) on {{ creationDate }}
          .report-generation-time(style="display: none;")
            span {{ reportGenerationTime }}

      template(v-slot:right)
        #tabs-wrapper(ref="tabWrapper")
          .tab-content.panel-padding
            .tab-pane
              v-authorship#tab-authorship(v-if="tabType === 'authorship'")
              v-zoom#tab-zoom(v-else-if="tabType === 'zoom'")
              #tab-empty(v-else)
                .title
                  h2 Welcome to this RepoSense report!
                  p The charts on the left show the contribution activities, grouped by repository and author.
                  p
                    | To view the code attributed to a specific author, click the &nbsp;
                    font-awesome-icon(icon="code")
                    | &nbsp; icon next to that author's name.
                    br
                    | To view the breakdown of commits made by a specific author, click the &nbsp;
                    font-awesome-icon(icon="list-ul")
                    | &nbsp; icon next to that author's name.
                    br
                    | To hide the code view and show only the activity charts, click the &nbsp;
                    font-awesome-icon(icon="caret-right")
                    | &nbsp; icon on the centre divider.
                  p
                    | See the &nbsp;
                    a(
                      v-bind:href="getUsingReportsUserGuideLink()", target="_blank"
                    )
                      strong User Guide
                    | &nbsp; to get a better understanding of how to interpret the report.

  template(v-else)
    .empty Please upload a .zip file generated by RepoSense.

    form#file-upload(onsubmit="return false;")
      input(type="file", accept=".zip", v-on:change="updateReportZip")
</template>


<script>
import JSZip from 'jszip';
import LoadingOverlay from 'vue-loading-overlay';
import { mapState } from 'vuex';

import vResizer from './components/v-resizer.vue';
import vZoom from './views/v-zoom.vue';
import vSummary from './views/v-summary.vue';
import vAuthorship from './views/v-authorship.vue';


const loadingResourcesMessage = 'Loading resources...';

const app = {
  name: 'app',
  data() {
    return {
      repos: {},
      users: [],
      userUpdated: false,

      isLoadingOverlayEnabled: false,
      loadingOverlayOpacity: 1,

      tabType: 'empty',
      creationDate: '',
      reportGenerationTime: '',
      errorMessages: {},
    };
  },
  watch: {
    '$store.state.tabZoomInfo': function () {
      if (this.$store.state.tabZoomInfo.isRefreshing) {
        return;
      }
      this.activateTab('zoom');
    },
    '$store.state.tabAuthorshipInfo': function () {
      this.activateTab('authorship');
    },
    '$store.state.loadingOverlayCount': function () {
      this.isLoadingOverlayEnabled = this.$store.state.loadingOverlayCount > 0;
    },
  },
  methods: {
    async loadJSON(fname) {
      if (window.REPORT_ZIP) {
        const zipObject = window.REPORT_ZIP.file(fname);
        if (zipObject) {
          try {
            return JSON.parse(await zipObject.async('text'));
          } catch (e) {
            throw new Error('Uploaded JSON is invalid.');
          }
        } else {
          throw new Error('Uploaded zip file is invalid.');
        }
      }
      try {
        const REPORT_DIR = '.';
        const response = await fetch(`${REPORT_DIR}/${fname}`);
        // Not directly returned in case response is not actually json.
        const json = await response.json();
        return json;
      } catch (e) {
        throw new Error(`Unable to read ${fname}.`);
      }
    },
    async loadSummary() {
      window.REPOS = {};
      let data = {};
      try {
        data = await this.loadJSON('summary.json');
      } catch (error) {
        if (error.message === 'Unable to read summary.json.') {
          return null;
        }
        throw error;
      }
      const { reportGeneratedTime, reportGenerationTime } = data;
      window.sinceDate = data.sinceDate;
      window.untilDate = data.untilDate;
      window.repoSenseVersion = data.repoSenseVersion;
      window.isSinceDateProvided = data.isSinceDateProvided;
      window.isUntilDateProvided = data.isUntilDateProvided;
      document.title = data.reportTitle || document.title;

      const errorMessages = {};
      Object.entries(data.errorSet).forEach(([repoName, message]) => {
        errorMessages[repoName] = message;
      });

      window.DOMAIN_URL_MAP = data.supportedDomainUrlMap;

      const names = [];
      data.repos.forEach((repo) => {
        const repoName = `${repo.displayName}`;
        window.REPOS[repoName] = repo;
        names.push(repoName);
      });
      return {
        creationDate: reportGeneratedTime,
        reportGenerationTime,
        errorMessages,
        names,
      };
    },

    async loadCommits(repoName) {
      const folderName = window.REPOS[repoName].outputFolderName;
      const commits = await this.loadJSON(`${folderName}/commits.json`);
      const res = [];
      const repo = window.REPOS[repoName];

      Object.keys(commits.authorDisplayNameMap).forEach((author) => {
        if (author) {
          const obj = {
            name: author,
            repoId: repoName,
            variance: commits.authorContributionVariance[author],
            displayName: commits.authorDisplayNameMap[author],
            dailyCommits: commits.authorDailyContributionsMap[author],
            fileTypeContribution: commits.authorFileTypeContributionMap[author],
          };

          this.setContributionOfCommitResultsAndInsertRepoId(obj.dailyCommits, obj.repoId);

          const searchParams = [
              repo.displayName,
              obj.displayName, author,
          ];

          obj.searchPath = searchParams.join('_').toLowerCase();
          obj.repoName = `${repo.displayName}`;
          obj.location = `${repo.location.location}`;

          res.push(obj);
        }
      });

      repo.commits = commits;
      repo.users = res;

      return res;
    },

    loadAuthorship(repoName) {
      const folderName = window.REPOS[repoName].outputFolderName;
      return this.loadJSON(`${folderName}/authorship.json`)
          .then((files) => {
            window.REPOS[repoName].files = files;
            return files;
          });
    },

    // calculate and set the contribution of each commitResult and insert repoId into commitResult
    // since not provided in json file
    setContributionOfCommitResultsAndInsertRepoId(dailyCommits, repoId) {
      dailyCommits.forEach((commit) => {
        commit.commitResults.forEach((result) => {
          result.repoId = repoId;
          result.insertions = Object.values(result.fileTypesAndContributionMap)
              .reduce((acc, fileType) => acc + fileType.insertions, 0);
          result.deletions = Object.values(result.fileTypesAndContributionMap)
              .reduce((acc, fileType) => acc + fileType.deletions, 0);
        });
      });
    },
    // model functions //
    updateReportZip(evt) {
      this.users = [];

      JSZip.loadAsync(evt.target.files[0])
          .then((zip) => {
            window.REPORT_ZIP = zip;
          }, () => {
            window.alert('Either the .zip file is corrupted, or you uploaded a .zip file that is not generated '
                + 'by RepoSense.');
          })
          .then(() => this.updateReportView());
    },

    updateReportDir() {
      window.REPORT_ZIP = null;

      this.users = [];
      this.updateReportView();
    },

    async updateReportView() {
      this.$store.commit('incrementLoadingOverlayCount', 1);
      this.$store.commit('updateLoadingOverlayMessage', loadingResourcesMessage);
      this.userUpdated = false;
      try {
        const {
          creationDate,
          reportGenerationTime,
          errorMessages,
          names,
        } = await this.loadSummary();
        if (names === null) {
          return;
        }
        this.creationDate = creationDate;
        this.reportGenerationTime = reportGenerationTime;
        this.errorMessages = errorMessages;
        this.repos = window.REPOS;
        await Promise.all(names.map((name) => (
          this.loadCommits(name)
        )));
        this.loadingOverlayOpacity = 0.5;
        this.getUsers();
        this.renderTabHash();
        this.userUpdated = true;
      } catch (error) {
        window.alert(error);
      } finally {
        this.$store.commit('incrementLoadingOverlayCount', -1);
      }
    },
    getUsers() {
      const full = [];
      Object.keys(this.repos).forEach((repo) => {
        if (this.repos[repo].users) {
          full.push(this.repos[repo]);
        }
      });
      this.users = full;
    },

    // handle opening of sidebar //
    activateTab(tabName) {
      if (this.$refs.tabWrapper) {
        this.$refs.tabWrapper.scrollTop = 0;
      }

      this.tabType = tabName;
      this.$store.commit('updateTabState', true);
      window.addHash('tabType', this.tabType);
      window.encodeHash();
    },

    renderAuthorShipTabHash(minDate, maxDate) {
      const hash = window.hashParams;
      const info = {
        author: hash.tabAuthor,
        repo: hash.tabRepo,
        isMergeGroup: hash.authorshipIsMergeGroup === 'true',
        isRefresh: true,
        minDate,
        maxDate,
      };
      const tabInfoLength = Object.values(info).filter((x) => x !== null).length;
      if (Object.keys(info).length === tabInfoLength) {
        this.$store.commit('updateTabAuthorshipInfo', info);
      } else if (hash.tabOpen === 'false' || tabInfoLength > 2) {
        this.$store.commit('updateTabState', false);
      }
    },

    renderZoomTabHash() {
      const hash = window.hashParams;
      const zoomInfo = {
        isRefreshing: true,
        zAuthor: hash.zA,
        zRepo: hash.zR,
        zAvgCommitSize: hash.zACS,
        zSince: hash.zS,
        zUntil: hash.zU,
        zFilterGroup: hash.zFGS,
        zFilterSearch: hash.zFS,
        zTimeFrame: hash.zFTF,
        zIsMerged: hash.zMG === 'true',
        zFromRamp: hash.zFR === 'true',
      };
      const tabInfoLength = Object.values(zoomInfo).filter((x) => x !== null).length;
      if (Object.keys(zoomInfo).length === tabInfoLength) {
        this.$store.commit('updateTabZoomInfo', zoomInfo);
      } else if (hash.tabOpen === 'false' || tabInfoLength > 2) {
        this.$store.commit('updateTabState', false);
      }
    },

    renderTabHash() {
      const hash = window.hashParams;
      if (!hash.tabOpen) {
        return;
      }
      this.$store.commit('updateTabState', hash.tabOpen === 'true');

      if (this.isTabActive) {
        if (hash.tabType === 'authorship') {
          let { since, until } = hash;

          // get since and until dates from window if not found in hash
          since = since || window.sinceDate;
          until = until || window.untilDate;
          this.renderAuthorShipTabHash(since, until);
        } else {
          this.renderZoomTabHash();
        }
      }
    },

    getRepoSenseHomeLink() {
      const version = window.repoSenseVersion;
      if (!version) {
        return `${window.HOME_PAGE_URL}/RepoSense/`;
      }
      return `${window.HOME_PAGE_URL}`;
    },

    getSpecificCommitLink() {
      const version = window.repoSenseVersion;
      if (!version) {
        return `${window.REPOSENSE_REPO_URL}`;
      }
      if (version.startsWith('v')) {
        return `${window.REPOSENSE_REPO_URL}/releases/tag/${version}`;
      }
      return `${window.REPOSENSE_REPO_URL}/commit/${version}`;
    },

    getUserGuideLink() {
      const version = window.repoSenseVersion;
      if (!version) {
        return `${window.HOME_PAGE_URL}/RepoSense/ug/index.html`;
      }
      return `${window.HOME_PAGE_URL}/ug/index.html`;
    },

    getUsingReportsUserGuideLink() {
      const version = window.repoSenseVersion;
      if (!version) {
        return `${window.HOME_PAGE_URL}/RepoSense/ug/usingReports.html`;
      }
      return `${window.HOME_PAGE_URL}/ug/usingReports.html`;
    },
  },

  computed: {
    ...mapState(['loadingOverlayMessage', 'isTabActive']),
  },

  components: {
    LoadingOverlay,
    vResizer,
    vZoom,
    vSummary,
    vAuthorship,
  },
  created() {
    window.decodeHash();
    this.updateReportDir();
  },
};

window.app = app;

export default app;
</script>


<style lang="scss">
@import './styles/style.scss';
@import './styles/panels.scss';
</style>
